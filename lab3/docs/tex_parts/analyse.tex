\chapter{Аналитическая часть}

\section{Алгоритм линейного поиска}

Поиск нужного элемента сводится к проходу с начала массива либо до совпадения, либо до конца массива \cite{search}. 

Пусть дан массив длины $N$ с индексами от 0 до $N - 1$. При расположении элемента на позиции с индексом $i$ потребуется $i + 1$ сравнение. В случае отсутствия элемента в массиве потребуется $N$ сравнений. Лучшим случаем для данного алгоритма будет нахождение нужного элемента на позиции 0, так как потребуется 1 сравнение. Худших случаев 2 - отсутствие элемента в массиве и расположение на позиции $N - 1$. Для них потребуется $N$ сравнений. Трудоёмкость в среднем рассчитывается по формуле $\frac{\sum_{\substack{i=1}}^N i + N}{N + 1} = \frac{N}{2} + \frac{N}{N + 1}$.

\section{Алгоритм бинарного поиска}

Данный алгоритм работает только для отсортированного массива \cite{search}. Поиск начинается со среднего элемента. Возможны 2 варианта алгоритма.

В 1 варианте поиск останавливается при совпадении. В противном случае происходит ещё одно сравнение элемента с текущим, чтобы отбросить половину массива, что возможно благодаря тому, что массив отсортирован, так как элементы с меньшими индексами будут меньше текущего, а с большими -- больше. Далее поиск повторяется либо до нахождения позиции, либо до сокращения размера диапазона поиска до 0.

Пусть дан массив длины $N$. Лучшим случаем для данного алгоритма будет нахождение нужного элемента при первом сравнении. Отсутствие элемента в массиве является худшим случаем и требует $2 * log_2{N}$ сравнений, что при больших $N$ меньше, чем трудоёмкость в среднем у линейного поиска.

Данный вариант возвращает первую найденную позицию. Это означает, что при наличии нескольких элементов с одинаковыми значениями неизвестно, какой из них вернется в качестве результата.

В 2 варианте поиск не останавливается при совпадении. Вместо этого каждый раз происходит только 1 сравнение, чтобы отбросить половину массива, и так до тех пор, пока размер диапазона поиска не уменьшится до 1. После этого происходит ещё одно сравнение для определения правильности поиска. Из-за этого во всех случаях количество сравнений будет $log_2{N} + 1$.

В данном варианте в зависимости от способа сравнения будет возвращаться либо наименьший индекс элемента, либо наибольший.

Для данной лабораторной работы выбран 1 вариант, так как по условию все числа в массиве различные. 

\section{Алгоритм сортировки}

\subsection{Быстрая сортировка}

На каждом шаге алгоритма выбирается опорный элемент, после чего массив делится на 2 части \cite{sort}. В одной из частей элементы больше опорного, в другой -- меньше. Далее операция повторяется с частями, пока их размер не достигнет 1.

В худшем случае алгоритм работает за $O(N^2)$, однако в среднем выходит $O(Nlog_2N)$.

\subsection{Сортировка слиянием}

В данном алгоритме массив сначала делится на 2 равные части \cite{sort}. Эта операция повторяется для частей до тех пор, пока их размер не станет равным 1. Затем части массива объединяются в порядке возрастания элементов. Благодаря тому, что объединение начинается с частей размером 1, все части при слиянии уже будут отсортированными.

Во всех случаях алгоритм работает за $O(Nlog_2N)$, но при этом требует память под ещё один массив.

\subsection{Пирамидальная сортировка}

Для данного алгоритма используется структура данных двоичная куча \cite{sort}. Сначала на массиве строится двоичная куча для поиска максимума. Затем в цикле с последнего элемента вершина кучи обменивается с текущим элементом, после чего размер кучи уменьшается на 1 и восстанавливается свойство кучи -- каждый родитель не меньше своих потомков.

Во всех случаях алгоритм работает за $O(Nlog_2N)$.

\subsection{Выбор алгоритма сортировки}

В таблице \ref{tab:sort} представлены результаты сравнения алгоритмов сортировки:

\begin{table}[h!]
	\small
	\caption{\label{tab:sort}Результаты сравнения алгоритмов сортировки}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			№  & Название & \makecell{л. с.} & \makecell{ср. с.} & \makecell{х. с.} & \makecell{Не нужен\\дополнительный\\массив}\\  
			\hline
			1  & \makecell{Быстрая\\сортировка} & $O(Nlog_2N)$ & $O(Nlog_2N)$ & $O(N^2)$ & +\\
			\hline
			2  & \makecell{Сортировка\\слиянием} & $O(Nlog_2N)$ & $O(Nlog_2N)$ & $O(Nlog_2N)$ & -\\
			\hline
			3  & \makecell{Пирамидальная\\сортировка} & $O(Nlog_2N)$ & $O(Nlog_2N)$ & $O(Nlog_2N)$ & +\\
			\hline
			
		\end{tabular}
	\end{center}
\end{table}

В результате сравнения была выбрана пирамидальная сортировка.

\section{Вывод}

В данном разделе были описаны алгоритмы поиска в массиве, а также выбран алгоритм сортировки.

