% Содержимое отчета по курсу Анализ алгоритмов

\aaunnumberedsection{ВВЕДЕНИЕ}{sec:intro}

Цель работы -- получение навыка работы с графовыми моделями. 

Задачи работы: 
\begin{itemize}
	\item выбрать фрагмент кода для анализа и входные данные для построения информационной и операционной историй;
	\item построить граф управления, информационный граф, операционную историю и информационную историю;
	\item сделать вывод о применимости графовых моделей.
\end{itemize}

\aasection{Выбор фрагмента кода и входных данных}{sec:select-data}

В листингах~\ref{lst:code0}-\ref{lst:code1} представлен выбранный для анализа фрагмент кода. В комментариях строкам присвоены номера для обозначения в графовых моделях.

\begin{lstlisting}[label=lst:code0,caption=Выбранный для анализа фрагмент кода~(начало)]
var queuesWaiting = (double[]) null; // 1
var worktime = .0; // 2
var stageTimes = new LinkedHashMap<String, Double>(); // 3
var records = 0; // 4
var queues = 0; // 5
for (var value : tasks.values()) { // 6
	value.sort(Comparator.comparing(a -> a[0])); // 7
	if (records == 0) { // 8
		records = value.size(); // 9
		queues = records >> 1; // 10
		queuesWaiting = new double[queues]; // 11
	}
	var times = new double[records]; // 12
	for (var i = 0; i < records; ++i) { // 13
		times[i] = Double.parseDouble(value.get(i)[0]); // 14
	}
	for (var i = 0; i < records; i += 2) { // 15
		queuesWaiting[i >> 1] += times[i + 1] - times[i]; // 16
		if (i > 0) { // 17
			var stage = value.get(i)[2].split("_")[1]; // 18
\end{lstlisting}
\clearpage
\begin{lstlisting}[label=lst:code1,caption=Выбранный для анализа фрагмент кода~(окончание)]	
			stageTimes.put(stage, stageTimes.getOrDefault(stage, .0) + times[i] - times[i - 1]); // 19
		}
	}
	worktime += times[records - 1] - times[0]; // 20
}
\end{lstlisting}

Фрагмент взят из статического метода~$getStats()$ класса~$LogsMerger$. Метод~$getStats()$ принимает на вход словарь~$tasks$, содержащий историю для каждой задачи в виде списка массивов. В таблице~\ref{tab:tasks} представлены ключи и значения в словаре $tasks$, которые использовались для построения операционной и информационной историй.

\begin{longtable}{|p{.1\textwidth - 2\tabcolsep}|p{.9\textwidth - 2\tabcolsep}|}
	\caption{\label{tab:tasks}Ключи и значения, хранящиеся в словаре tasks} \\
	\hline
	\makecell{Ключ} & \makecell{Значение} \\  
	\hline
	\makecell{1} & \makecell{$[[0.0, 1, created], [0.01, 1, start\_first], [0.05, 1, end\_first],$\\$[0.06, 1, start\_second], [0.09, 1, end\_second], [0.1, 1, destroyed]]$} \\
	\hline
	\makecell{2} & \makecell{$[[0.01, 2, created], [0.06, 2, start\_first], [0.11, 2, end\_first],$\\$[0.12, 2, start\_second], [0.18, 2, end\_second], [0.19, 2, destroyed]]$} \\
	\hline
	\makecell{3} & \makecell{$[[0.02, 3, created], [0.12, 3, start\_first], [0.15, 3, end\_first],$\\$[0.19, 3, start\_second], [0.22, 3, end\_second], [0.23, 3, destroyed]]$} \\
	\hline
\end{longtable}

\aasection{Графовые модели}{sec:graphs}

Информационное отношение --- отношение по передаче данных между вершинами такое, что во второй вершине используются данные, полученные в первой вершине. Информационный граф --- граф, вершинами которого являются строки кода, а рёбрами --- информационное отношение. Информационная история --- граф, вершинами которого являются срабатывания операторов, команд и строк кода, а рёбрами --- информационное отношение. Операционное отношение --- отношение по передаче управления между вершинами такое, что вторая вершина будет выполнена после первой. Граф управления --- граф, вершинами которого являются строки кода, а рёбрами --- операционное отношение. Операционная история --- граф, вершинами которого являются срабатывания операторов, команд и строк кода, а рёбрами --- операционное отношение. Операционная история строго линейна.

На рисунке~\ref{img:IG} представлен информационный граф. На рисунке~\ref{img:IH} представлена информационная история. На рисунке~\ref{img:OG} представлен граф управления. На рисунке~\ref{img:OH} представлена операционная история.

\FloatBarrier
\includeimage
{IG} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{!h} % Положение рисунка (см. figure из пакета float)
{0.5\textwidth} % Ширина рисунка
{Информационный граф} % Подпись рисунка
\FloatBarrier

\FloatBarrier
\includeimage
{IH} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{!h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Информацинная история} % Подпись рисунка
\FloatBarrier

\FloatBarrier
\includeimage
{OG} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h!} % Положение рисунка (см. figure из пакета float)
{0.6\textwidth} % Ширина рисунка
{Граф управления} % Подпись рисунка
\FloatBarrier

\FloatBarrier
\includeimage
{OH} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h!} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Операционная история} % Подпись рисунка
\FloatBarrier

Графовые модели показывают зависимости по данным и передаче управления между участками кода. Анализ данных моделей позволяет эффективнее распараллеливать программы путём выявления последовательных участков кода, между которыми либо нет конфликта по доступу к данным, либо такие конфликты могут быть решены с использованием средств взаимоисключения.

\aaunnumberedsection{ЗАКЛЮЧЕНИЕ}{sec:outro}

Цель работы достигнута. Решены все поставленные задачи: 
\begin{itemize}
	\item выбраны фрагмент кода для анализа и входные данные для построения информационной и операционной историй;
	\item построены граф управления, информационный граф, операционную историю и информационную историю;
	\item сделан вывод о применимости графовых моделей.
\end{itemize}
