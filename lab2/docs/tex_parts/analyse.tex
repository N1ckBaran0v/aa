\chapter{Аналитическая часть}


\section{Модель вычислений}

Модель вычислений описывает правила для задания оценки ресурсной эффективности алгоритмов.

Трудоёмкость следующих операций принимается за 1: $=$, $+$, $-$, $+=$, $-=$, $==$, $!=$, $<$, $<=$, $>$, $>=$, $[]$, $<<$, $>>$, $<<=$, $>>=$, $\&\&$, $||$, $\&$, $|$, $\textasciicircum$, $\&=$, $|=$. 

Трудоёмкость следующих операций принимается за 2: $*$, $/$, $\%$, $*=$, $/=$, $\%=$. 

Трудоёмкость цикла рассчитывается следующим образом: пусть имеется цикл for (init; cond; inc) \{ body \}, где init -- блок инициализации переменных, cond -- блок проверки условия, inc -- блок изменения переменных, body -- тело цикла. Пусть цикл выполнился $N$ раз. Тогда трудоёмкость цикла $f_{for}$ рассчитывается по формуле \ref{eq:f_for}

\begin{equation}
	\label{eq:f_for}
	f_{for} = f_{init} + f_{cond} + N * (f_{cond} + f_{inc} + f_{body})
\end{equation}

где $f_{init}$ -- трудоёмкость блока инициализации, $f_{cond}$ -- трудоёмкость блока проверки условия, $f_{inc}$ -- трудоёмкость блока изменения переменных, $ f_{body}$ -- трудоёмкость тела цикла.

Трудоёмкость условного оператора рассчитывается следующим образом: пусть имеется условный оператор if (cond) then \{ body1 \} else \{ body2 \}, где cond -- блок проверки условия, body1 -- тело при выполнении условия, body2 -- тело при невыполнении условия. Тогда трудоёмкость условного оператора $f_{if}$ рассчитывается по формуле \ref{eq:f_if}

\begin{equation}
	\label{eq:f_if}
	f_{if} = f_{cond} + \begin{cases}
		f_{body1} & \text{; условие cond выполнилось}\\
		f_{body2} & \text{; иначе}\\
	\end{cases},
\end{equation}

где $f_{cond}$ -- трудоёмкость блока проверки условия, $ f_{body1}$ -- трудоёмкость тела при выполнении условия, $ f_{body2}$ -- трудоёмкость тела при невыполнении условия.

Операцией выделения памяти пренебрегаем.

\section{Алгоритмы перемножения матриц}

\subsection{Стандартный алгоритм}

Пусть даны матрица $A$ размером $N$ на $M$ (формула \ref{eq:m_a}) и матрица $B$ размером $M$ на $K$ (формула \ref{eq:m_b}).

\begin{equation}
	\label{eq:m_a}
	A_{NM} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1M} \\
		a_{21} & a_{22} & \ldots & a_{2M} \\
		\vdots & \vdots & \ddots & \vdots \\
		a_{N1} & a_{N2} & \ldots & a_{NM} 
	\end{pmatrix}
\end{equation}

\begin{equation}
	\label{eq:m_b}
	B_{MK} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1K} \\
		b_{21} & b_{22} & \ldots & b_{2K} \\
		\vdots & \vdots & \ddots & \vdots \\
		b_{M1} & b_{M2} & \ldots & b_{MK} 
	\end{pmatrix}
\end{equation}

Тогда матрица $C$ размером $N$ на $K$ (формула \ref{eq:m_с}), где $c_{ij}$ -- элемент матрицы $С$ в строке $i$ и столбце $j$ -- рассчитывается по формуле \ref{eq:c_ij}, называется произведением матриц A и B. 

\begin{equation}
	\label{eq:m_с}
	C_{NK} = \begin{pmatrix}
		с_{11} & c_{12} & \ldots & c_{1K} \\
		c_{21} & c_{22} & \ldots & c_{2K} \\
		\vdots & \vdots & \ddots & \vdots \\
		c_{N1} & c_{N2} & \ldots & c_{NK} 
	\end{pmatrix}
\end{equation}

\begin{equation}
	\label{eq:c_ij}
	\text{c}_{ij} = \sum_{\substack{k=1}}^M a_{ik} * b_{kj}
\end{equation}

Из определения следует, что количество столбцов в первой матрице должно совпадать с количеством строк во второй матрице, в противном случае произведение невозможно получить. Стандартный алгоритм реализует эту формулу.

\subsection{Алгоритм Винограда}

В случае четного $M$ $c_{ij}$ можно вычислить по формуле \ref{eq:c_ij2} \cite{vinograd}.

\begin{equation}
	\label{eq:c_ij2}
	\text{c}_{ij} = \sum_{\substack{k=1}}^{\frac{M}{2}} ((a_{i(2k-1)} + b_{(2k)j}) * (a_{i(2k)} + b_{(2k-1)j})) - 
	\sum_{\substack{k=1}}^{\frac{M}{2}} a_{i(2k-1)} * a_{i(2k)} -
	\sum_{\substack{k=1}}^{\frac{M}{2}} b_{(2k-1)j} * b_{(2k)j}
\end{equation}

Для нечетного $M$ достаточно добавить недостающее произведение. 

Идея алгоритма Винограда заключается в сокращении количества операций умножения для увеличения скорости вычислений. Суммы во втором и третьем слагаемом можно посчитать заранее и переиспользовать для всех элементов строки или столбца. В таком случае для каждого $c_{ij}$ используется почти в 2 раза меньше операций умножения.

\section{Оптимизации}

Для каждого алгоритма будут рассмотрены следующие оптимизации:

\begin{enumerate}[label={\arabic*)}]
	\item замена умножения на 2 на двоичный сдвиг;
	\item использование оператора сложения с присваиванием ({+=});
	\item вынос начальной итерации из цикла.
\end{enumerate}

\section{Вывод}

В данном разделе была описана модель вычислений, рассмотрены стандартный алгоритм и алгоритм Винограда умножения матриц, а также оптимизации к ним.
